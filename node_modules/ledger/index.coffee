class Purchase
    constructor: (purchase) ->
        [@id, @creditor, @amount, @debtors, @description] = [purchase.id,
                                                             purchase.creditor,
                                                             purchase.amount,
                                                             purchase.debtors,
                                                             purchase.description]
        @share = @amount / @debtors.length

    total_share: (person_name) ->
        return (@debtors.filter (debtor) -> debtor == person_name).length * @share

class Person

    constructor: (@name) ->
        @balance = 0
        @_tmp_balance = 0
        @purchases = []
        @transfers = []

    push_purchase: (id) ->
        idx = @purchases.indexOf (id)
        if idx == -1
            @purchases.push(id)

    push_transfer: (amount, to) ->
        @transfers.push({amount:amount, to:to})

class Ledger

    ROUNDOFF_TOL: 1e-10

    constructor: (@name='', ops_dict=null) ->
        @ops = []
        @people = []
        @purchases = {}
        @total_cost = 0

    valueOf: ->
        return "<Ledger (name=#{@name}, total_cost=#{@total_cost})>"

    round: (flt) ->
        return Math.round(flt*100)/100

    summary: ->
        string = "#{@name} | Cost: #{@round @total_cost} (#{@round (@total_cost/@people.length)}/person)\n"
        for person in @people
            if Math.abs(person.balance) > @ROUNDOFF_TOL
                if person.balance > 0
                    string += "#{person.name} is owed #{@round person.balance}\n"
                else if person.balance < 0
                    string += "#{person.name} owes #{@round -person.balance}:\n"
                    for t in person.transfers
                        string += "    #{@round t['amount']} to #{t['to'].name}\n"
        return string

    put: (opcode, payload) ->
        switch opcode
            when "add_purchase"
                @_check_purchase payload
                new_purchase = @_copy_purchase payload
                id = @_uniqueId()
                new_purchase.id = id
                @ops.push {id: @_uniqueId(), opcode: opcode, payload: new_purchase}
                @_process_last_op()
                return {retcode: 'ok', id: new_purchase.id}
            when "del_purchase"
                if @_has_active_purchase(payload.id)
                    @ops.push {id: @_uniqueId(), opcode: opcode, payload: payload}
                    @_process_last_op()
                    return {retcode: 'ok'}
                return {retcode: 'unknown_purchase'}
            when "chg_purchase"
                @_check_purchase payload
                if @_has_active_purchase(payload.id)
                    new_purchase = @_copy_purchase payload
                    @ops.push {id: @_uniqueId(), opcode: opcode, payload: new_purchase}
                    @_process_last_op()
                    return {retcode: 'ok'}
                else
                    return {retcode: 'unknown_purchase'}
            else return {retcode: "unknown_opcode"}

    squash: (ops=null, from_idx=0) ->
        top = false
        if ops == null
            top = true
            ops = @ops
        slice = ops.slice(from_idx)
        if slice.length == 0
            return ops
        first_op = slice[0]
        if first_op.opcode != "del_purchase"
            last_idx = @_last_op_for_purchase(slice, first_op.payload.id)
            if last_idx > 0
                last_op = slice[last_idx]
                switch last_op.opcode
                    when "del_purchase"
                        if first_op.opcode == "add_purchase"
                            new_slice = []
                        else
                            new_slice = [{id: @_uniqueId(), opcode: last_op.opcode, payload: last_op.payload}]
                    when "chg_purchase"
                        if first_op.opcode == "add_purchase"
                            new_slice = [{id: @_uniqueId(), opcode: first_op.opcode, payload: last_op.payload}]
                        else
                            new_slice = [{id: @_uniqueId(), opcode: last_op.opcode, payload: last_op.payload}]
                    else
                slice = new_slice.concat @_strip_purchase_id(slice, first_op.payload.id)
            idx = 0
        if top
            @ops = ops.slice(0, from_idx).concat @squash(slice, 1)
        else
            return ops.slice(0, from_idx).concat @squash(slice, 1)

    compute_transfers: ->
        @people.sort (a,b) ->
            if a.balance < b.balance then return -1 else 1
        l = @people.slice()

        for p in l
            p._tmp_balance = p.balance
            p.transfers = []

        done = l.length <= 1

        # Look for perfect matches first
        if not done
            i_start = 0
            i_end = l.length - 1
            exclude = []

            while i_start < i_end
                cur_debtor   = l[i_start]
                cur_creditor = l[i_end]

                if Math.abs(cur_debtor._tmp_balance) < @ROUNDOFF_TOL and Math.abs(cur_creditor._tmp_balance) < @ROUNDOFF_TOL
                    return

                if Math.abs(cur_debtor._tmp_balance + cur_creditor._tmp_balance) < @ROUNDOFF_TOL
                    cur_debtor.push_transfer cur_creditor._tmp_balance, cur_creditor
                    cur_debtor._tmp_balance = cur_creditor._tmp_balance = 0
                    exclude.push cur_debtor
                    exclude.push cur_creditor
                    i_start += 1
                    i_end -= 1

                else if -cur_debtor._tmp_balance > cur_creditor._tmp_balance
                    i_start += 1
                else
                    i_end -= 1

            l = l.filter (p) -> p not in exclude

        done = l.length <= 1

        while not done

            start = l[0]
            end   = l.slice(-1)[0]

            if start == end
                if Math.abs(start._tmp_balance) > @ROUNDOFF_TOL
                    console.log('Balancing error: #{start._tmp_balance}')
                break

            if Math.abs(start._tmp_balance + end._tmp_balance) < @ROUNDOFF_TOL
                start.push_transfer end._tmp_balance, end
                start._tmp_balance = end._tmp_balance = 0
                l = l.slice(1, -1)
            else if -start._tmp_balance > end._tmp_balance
                start.push_transfer end._tmp_balance, end
                start._tmp_balance += end._tmp_balance
                end._tmp_balance = 0
                l = l.slice(0, -1)
            else
                start.push_transfer -start._tmp_balance, end
                end._tmp_balance += start._tmp_balance
                start._tmp_balance = 0
                l = l.slice(1)

            done = l.length == 0

    _check_purchase: (purchase) ->
        if not purchase.creditor?.length > 0
            throw new Error 'no creditor'
        if not purchase.amount > 0
            throw new Error 'no amount'
        if not purchase.debtors?.length > 0
            throw new Error 'no debtors'
        if not purchase.debtors.every((x) -> x.length > 0)
            throw new Error 'some debtors are empty'
        if not purchase.description?.length > 0
            throw new Error 'no description'
        return true

    _process_last_op: () ->
        op = @ops.slice(-1)[0]
        purchase = op.payload
        switch op.opcode
            when "del_purchase"
                new_people = []
                purchase = @purchases[purchase.id]
                for idx, p of @people
                    if p.name == purchase.creditor
                        p.balance -= purchase.amount
                    if p.name in purchase.debtors
                        p.balance += purchase.total_share(p.name)
                    @_pop(p.purchases, purchase.id)
                    if p.purchases.length > 0
                        new_people.push(p)
                @people = new_people
                @total_cost -= purchase.amount
                delete @purchases[purchase.id]
            else
                if op.opcode == "chg_purchase"
                    old_purchase_obj = @purchases[purchase.id]
                    @total_cost -= old_purchase_obj.amount
                purchase_obj = new Purchase(purchase)
                @purchases[purchase.id] = purchase_obj
                @total_cost += purchase_obj.amount
                p = @_get_insert_person(purchase_obj.creditor)
                if op.opcode == "chg_purchase"
                    p.balance -= old_purchase_obj.amount
                p.balance += purchase_obj.amount
                p.push_purchase(purchase.id)
                for d in purchase_obj.debtors
                    p = @_get_insert_person(d)
                    p.push_purchase(purchase_obj.id)
                    if op.opcode == "chg_purchase"
                        p.balance += old_purchase_obj.share
                    p.balance -= purchase_obj.share

    _uniqueId: (length=8) ->
        id = ""
        id += Math.random().toString(36).substr(2) while id.length < length
        id.substr 0, length

    _strip_purchase_id: (array, id) ->
        ret = []
        for op in array
            if op.payload.id != id
                ret.push(op)
        return ret

    _has_active_purchase: (id) ->
        return @purchases[id]?

    _last_op_for_purchase: (array, id) ->
        for idx in [array.length-1..0] by -1
            op = array[idx]
            if op.payload.id == id
                break
        return idx

    _copy_purchase: (purchase) ->
        copy = {}
        for k, v of purchase
            copy[k] = v
        return copy

    _get_insert_person: (person_name) ->
        for p in @people
            if person_name == p.name
                return p
        p = new Person(person_name)
        @people.push(p)
        return p

    _pop: (array, item) ->
        idx = array.indexOf(item)
        if idx != -1
            array.splice(idx, 1)

module.exports.Ledger = Ledger
